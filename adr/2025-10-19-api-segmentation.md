# ADR: Сегментация API и контуров сайта

- **Статус:** Proposed  
- **Дата:** 2025-10-19  
- **Область:** backend платформы, безопасность, инфраструктура

## Контекст

Текущая реализация сайта и админ-панели использует общий бэкенд, из-за чего:
- отсутствует чёткое разграничение привилегий между публичными и административными клиентами;
- чувствительные операции (модерация, биллинг, управление правами) доступны в том же контуре, что и пользовательские сценарии;
- сложно внедрять политику безопасности (MFA, ротация ключей, аудит), потому что нет формализованных уровней доверия;
- тестирование и релизы админ-функционала влияют на стабильность пользовательского сайта.

Нужно десегментировать API, зафиксировать интеракции между контурами и определить процесс внедрения, чтобы повысить безопасность, управляемость и скорость развития продукта.

## Решение

### Архитектура контуров
- Вводим три логических контура:
  1. `Public API` — чтение публичных данных, авторизация пользователей, взаимодействие с основной витриной.
  2. `Admin API` — операции модераторов и сотрудников (управление контентом, пользователями, доступами).
  3. `Operations API` — высокорисковые процессы (биллинг, финансовые отчёты, системные настройки, массовые рассылки).
- Для каждого контура поднимаем отдельный reverse-proxy (или маршрутизацию в существующем gateway) и изолируем сетевой доступ (VPC/Firewall правила).
- Публичный фронтенд использует только `Public API`. Админка делится на два приложения: `admin-lite` (модерация, контент) → `Admin API`, и `admin-ops` (финансы, уведомления) → `Operations API`.

### Аутентификация и авторизация
- Центральный IdP выдаёт короткоживущие JWT токены с claim `audience` и `role`.  
  Роли: `user`, `moderator`, `admin`, `finance`.  
  Приложения получают только нужные аудитории (`public`, `admin`, `ops`).
- Для внутренних сервисов (cron, интеграции) используем сервис-аккаунты с OAuth `client credentials`; ключи храним в секрет-хранилище и ротируем автоматически.
- На уровне API внедряем policy-middleware, который проверяет `audience`, `role`, а также включает атрибуты в правила допуска (например, feature flags для модераторов).

### Управление данными и логирование
- Каждому контуру сопоставляем отдельные базы/схемы или схемы доступа в единой базе (минимум — разные пользователи БД с ограниченными правами).
- Включаем обязательное логирование всех административных запросов (сессия, IP, payload hash) и отдельный алертинг на отклонения.
- Для операций с персональными данными в `Operations API` добавляем обязательное шифрование на уровне транспорта и хранения.

### CI/CD и эксплуатация
- Разделяем пайплайны деплоя: публичные сервисы не зависят от релизов админских подсистем.
- Выделяем сегментированный staging, чтобы тесты модерации и биллинга не блокировали пользовательские проверки.
- Настраиваем автоматические smoke-тесты, покрывающие маршруты каждого контура (positive/negative сценарии на допуск).

### Примеры curl-запросов
- **Public API (пользователь):**
  ```sh
  curl -X GET https://api-public.caves.local/v1/profile/me \
       -H "Authorization: Bearer <user_token>" \
       -H "X-Audience: public"
  ```
- **Admin API (модерация):**
  ```sh
  curl -X POST https://api-admin.caves.local/v1/moderation/reports/review \
       -H "Authorization: Bearer <moderator_token>" \
       -H "X-Audience: admin" \
       -H "Content-Type: application/json" \
       -d "{\"report_id\": \"9d0c7c71-6d82-4c63-9c35-9a0adcf2f9f1\", \"decision\": \"approve\"}"
  ```
- **Operations API (финансы):**
  ```sh
  curl -X GET https://api-ops.caves.local/v1/billing/reports/daily \
       -H "Authorization: Bearer <finance_token>" \
       -H "X-Audience: ops" \
       -H "Accept: application/json"
  ```
Примеры демонстрируют раздельные домены контуров и обязательные заголовки `Authorization` и `X-Audience`.

## План работ

1. **Инвентаризация и аудит текущих эндпоинтов**  
   - Каталогизировать все маршруты, типы клиентов, чувствительность данных.  
   - Определить зоны риска (админские методы в публичных контроллерах, слабые проверки прав).  
   - Результат: таблица эндпоинтов с классификацией по контурам и приоритетами корректировок.

2. **Политика доступа и модель ролей**  
   - описать матрицу `роль × действие`.  
   - Зафиксировать TTL токенов, требования MFA, правила ротации ключей.  
   - Результат: утверждённая политика доступа и спецификация токенов (claims, scopes). См. `docs/api-inventory/access-policy.md`.

3. **Архитектурный дизайн и маршрутизация**  
   - Разработать схему сетевого разделения (gateway, firewall, сервисные подсети).  
   - Подготовить ADR по паттерну деплоя (отдельные сервисы/namespace, DNS, балансировка).  
   - Результат: диаграммы и конфигурации маршрутизации, согласованные с DevOps. См. `docs/api-inventory/network-architecture.md` и `docs/api-inventory/network-architecture.svg`.

4. **Имплементация контуров в коде**  
   - Вынести админские контроллеры в отдельные модули/сервисы.  
   - Добавить middleware проверки `audience/role`, ограничить доступ к БД по учетным данным.  
   - Результат: кодовая база с явным разделением API, фича-флаги для поэтапного включения.

5. **Тестирование и проверка безопасности**  
   - Автоматизировать интеграционные тесты на отказ по правам, smoke-тесты для каждого контура.  
   - Запустить static/dynamic security scan, провести ручной пентест критичных операций.  
   - Результат: отчёты тестов, исправленные замечания, baseline показателей безопасности.

6. **Мониторинг и эксплуатация**  
   - Настроить мониторинг маршрутов и алерты на ошибочные попытки доступа.  
   - Ввести аудит логов и ретенцию (например, 180 дней) с поиском по критериям безопасности.  
   - Результат: дашборды и регламенты реагирования, SLA по обработке инцидентов.

7. **Документация и обучение**  
   - Обновить API-спецификации, гайды по интеграции, плейбуки для модераторов и финкоманды.  
   - Задокументировать процесс выдачи прав и ротации ключей.  
   - Результат: консистентные документы и чек-листы для онбординга и поддержки.

## Детализация имплементации контуров

### Каркас приложений
- Утвердить модель из трёх контуров (`public`, `admin`, `ops`) и зафиксировать соответствующие ingress-правила и наборы учётных данных в этом ADR.
- В `apps/backend/app/api_gateway` реализовать регистраторы, монтирующие роутеры по контурам (`register_public()`, `register_admin()`, `register_ops()`), и подключить contour-aware middleware.
- Вынести проверки аудитории и ролей в единый middleware `apps/backend/app/api_gateway/middlewares/audience.py`, включающий последовательность `resolve_client → resolve_contour → enforce_role`.
- Конфигурацию ограниченных доступов к БД хранить в `apps/backend/infra/db/config.py`, где каждой роли сопоставлен собственный DSN/пул; инъекцию в сервисы выполнить через `container_registry.py`.
- Для управляемого rollout’а добавить feature-флаги `admin_contour.enabled` и `ops_contour.enabled` в `apps/backend/domains/platform/flags/service.py` с фиксацией прогресса в `docs/api-inventory/findings.md`.

### Доменные правила и хранение кода
- В каждом домене завести подпакеты `api/public` и `api/admin` (при необходимости `api/ops`), чтобы публичные и административные контроллеры не пересекались. Пример: `apps/backend/domains/product/achievements/api/public/http.py` и `.../admin/http.py`.
- В `platform/moderation` весь HTTP-слой переносится под `api/admin`; потенциальные публичные сценарии выделяются в `api/public`.
- `platform/admin` переименовать в `platform/ops`, сконцентрировав там биллинг, системные настройки и прочие операции высокого риска.
- В доменах `platform/users` и `platform/core` разбить эндпоинты: маршруты с `jwt-admin` остаются в `api/admin`, пользовательские — в `api/public`, с выделением отдельных сервис-слоёв.
- Для продуктовых доменов (`achievements`, `profile`, `quests`, `referrals`, `tags`) админ-операции получают собственный `application/admin_service.py` и отдельные DTO (например, `schemas_admin.py`), чтобы не смешивать модели.
- Общие зависимости (`require_admin`, `get_current_user`, rate limiting) вынести на уровень `apps/backend/app/api_gateway/deps/{public,admin,ops}.py`, минимизируя дублирование в доменах.

### Порядок миграции ручек (приоритеты)
1. `platform.moderation` — все `/api/moderation/**` переносятся в `api/admin`, подключается новый middleware и включается фича-флаг `admin_contour.moderation`; после переноса выполняются smoke-тесты модераторского UI.
2. Чувствительные ручки `platform.core` (`/v1/settings/**`, `/v1/users/**`): разделить на `public` и `admin`, ограничить доступ к админским use-case’ам через новые креды.
3. Продуктовые домены (`/v1/admin/**`, `PUT /v1/profile/{user_id}` и др.): создать зеркальные admin-подмодули, адаптировать импорты и включить `admin_contour.product`.
4. `platform.search` и `platform.quota`: админские операции индексации и лимитов переносятся в `api/admin`, конфигурация rate limiter'а переразводится по контурам.
5. Дополнительные high-priority POST/PUT в `platform.moderation` (санкции, решения) усиливаются аудитом после переноса.
6. Эндпоинты контура `ops` (например, биллинг) мигрируют последними: `platform/admin` окончательно превращается в `platform/ops`, `/v1/settings/billing/**` обслуживаются отдельным приложением с mTLS и ops-учётками.

### Подготовительные действия
- Обновить `docs/api-inventory/endpoints.md`, указав новый модуль, контур и фича-флаг для каждой ручки.
- В `docs/api-inventory/findings.md` описать риски миграции (downtime, совместимость клиентов) и получить подтверждение от заинтересованных команд.
- В CI добавить матричные smoke-тесты и интеграционные проверки для `public`, `admin` и `ops`; результаты публиковать в отчётах.
- После каждого этапа миграции фиксировать совместимость и обратимые действия в этом ADR и смежных документах.

## Ожидаемый результат

- Публичный сайт и админка используют разные транспортные контуры и не мешают друг другу при релизах.
- Чувствительные операции защищены дополнительными слоями (MFA, короткие токены, ограниченные БД-пользователи).
- Количество уязвимостей класса «неправильная авторизация» значительно снижается, а обнаружение попыток атаки упрощается.
- Команды разработки получают понятные границы ответственности и ускоряют выпуск функционала без доп. рисков.

## Технические риски и меры

| Риск | Влияние | Меры минимизации |
|------|---------|------------------|
| Несовместимость клиентов после разделения маршрутов | Простой фронтенда, обращения к устаревшим URL | Ввести фаза-флаги и прокси-слой с обратной совместимостью, заранее обновить SDK/клиенты, настроить алерты на 404/401. |
| Регресс функционала из-за разбиения сервисов | Сбой критичных сценариев (модерация, биллинг) | Набор интеграционных тестов и smoke-тестов, поэтапный rollout (канарейка), fallback на старый контур на время миграции. |
| Перегрузка системы аутентификации и выдачи токенов | Повышенные задержки, ошибки 5xx при логине | Горизонтальное масштабирование IdP, кэширование проверок токенов, мониторинг latency и авто-масштабирование. |
| Ошибки конфигурации сетевых правил | Утечка административного доступа или полная недоступность админки | Infrastructure-as-Code с ревью, автоматические проверки (policy-as-code), staged-deploy сетевых изменений. |
| Повышенная задержка из-за дополнительного прокси слоя | Ухудшение UX публичного сайта | Перенос статики в CDN, оптимизация keep-alive, замеры latency до и после, возможность обхода промежуточных слоёв для low-latency эндпоинтов. |
| Сложности с синхронизацией данных между контурами | Неконсистентные данные (например, статусы модерации) | Использовать очереди/событийную шину и транзакционные outbox-паттерны, валидационные джобы, наблюдаемость по лагам. |

## Метрики успеха

- Доля админских запросов, проходящих через `Public API`, стремится к нулю.
- Количество инцидентов категории «неправильный доступ» сокращается не менее чем на 80%.
- SLA авторизации пользователей и админов удерживается в рамках ≤ 300 мс P95.
- Покрытие тестов на отказ по правам ≥ 90% для критичных эндпоинтов.

## Сопутствующие изменения

- Требуется обновить документацию по уведомлениям и биллингу с учётом новых контуров.
- Планируется пересмотр deploy-процессов (GitOps/ArgoCD) для раздельного релиза Public/Admin/Operations.
- Необходимо синхронизировать будущие UX-инициативы с новой сегментацией, чтобы избежать дублирования логики.
