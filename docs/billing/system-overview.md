# Система биллинга EVM-модулей

## Назначение документа
Этот документ описывает общую архитектуру биллинга для EVM-контрактов из `apps/crypto/evm`. Основная цель — зафиксировать состав компонентов, точки интеграции и ключевые потоки, чтобы обеспечить единое понимание при разработке и последующем сопровождении.

## Архитектурные компоненты
- **CoreSystem** — реестр модулей и ролей. Через него выдаются права и регистрируются сервисы (платёжный шлюз, PlanManager, Permit2 и т. д.).
- **PaymentGateway** — единственная точка входа для списаний и конвертации валют (`IPaymentGateway`). Биллинг не работает без корректно настроенного шлюза.
- **SubscriptionManager** — управляет состоянием подписок, принимает платежи, инициирует события `SubscriptionCharged`, хранит данные о ретраях.
- **PlanManager** — CRUD по тарифным планам, проверка подписей авторов и ограничения по активным планам.
- **Marketplace** — приём офчейн-листингов и продажи с ончейн-оплатой; не участвует в рекуррентных списаниях, но использует тот же шлюз.
- **Backend-библиотека** — набор утилит для генерации EIP-712 подписей (`SignatureLib.Plan`/`Listing`), управления ролями и общения с контрактами.
- **Billing worker** — сервис, который периодически вызывает `SubscriptionManager.charge`/`chargeBatch` и обрабатывает неудачные списания.
- **Frontend** — отображает планы, подписки и статусы оплат, инициирует пользовательские транзакции (подписка, отмена, управляет депозитом).

## Роли и права
- `FEATURE_OWNER_ROLE` — право регистрировать модули и сервисы в CoreSystem (нужен для фабрик и административных операций).
- `AUTHOR_ROLE` — авторы, которые создают планы подписок.
- `OPERATOR_ROLE` — управление статусами планов, ручные активации/отмены, форсированные действия.
- `AUTOMATION_ROLE` — аккаунт воркера, который выполняет автосписания.
- `GOVERNOR_ROLE` — изменение глобальных параметров (например, лимит активных планов в PlanManager).

Для внутреннего тестирования допускается использование одного кошелька с набором всех ролей. На бою роли необходимо разделить (автор ≠ оператор ≠ автоматизация) и ограничить доступ к ключам.

## Жизненный цикл подписки
1. **Создание плана**
   - Backend формирует структуру `SignatureLib.Plan`, рассчитывает хеш и подписывает приватным ключом автора.
   - Автор вызывает `PlanManager.createPlan`, прикладывая подпись и URI с метаданными.
   - PlanManager проверяет роль автора, подпись и лимит активных планов, затем сохраняет план.

2. **Подписка пользователя**
   - Frontend получает данные плана и сигнатуру автора из backend.
   - Пользователь вызывает `SubscriptionManager.subscribe` или `subscribeWithToken`, при необходимости передаёт permit/Permit2.
   - Контракт валидирует цепочку, цену, подпись автора и обращается в `PaymentGateway.processPayment`.
   - По завершении вызывается `_activateSubscription`, сохраняется состояние и эмитируется `SubscriptionActivated`.

3. **Автоматическое списание**
   - Worker периодически формирует батч пользователей и вызывает `charge`/`chargeBatch`.
   - Контракт проверяет наступление даты платежа, обращается к платёжному шлюзу и обновляет `nextChargeAt`.
   - При успешном списании создаётся событие `SubscriptionCharged`, при недостатке депозитов или ошибке шлюза — `ChargeSkipped` с кодом причины.
   - Если списание не удалось, worker может вызвать `markFailedCharge`, что создаёт ретрай или переводит подписку в статус `Inactive`.

4. **Отмена / возврат**
   - Пользователь вызывает `unsubscribe`, что переводит состояние в `Inactive` и возвращает остаток депозита.
   - Оператор может вызвать `forceCancel` с нужной причиной.
   - При необходимости оператор или губернатор могут менять статус плана, переводя всех подписчиков в неактивное состояние при следующем списании.

## Интеграция с платёжным шлюзом
- `PaymentGateway` обязан поддерживать:
  - Валидацию поддерживаемых токенов (`isPairSupported`).
  - Конвертацию сумм (`convertAmount`) для оплаты в альтернативной валюте.
  - Списания с возможностью удержать комиссию и вернуть чистую сумму мерчанту (`processPayment`).
- Для каждого модуля (subscription/marketplace) шлюз регистрируется в CoreSystem через `core.setService(instanceId, 'PaymentGateway', addr)`.
- Дополнительные сервисы (например, Permit2, прайс-оракул) конфигурируются аналогично с соответствующим алиасом.

## Требования к backend-библиотеке
- Генерация EIP-712 домена и хеша для `Plan`/`Listing`, хранение соли и управление `expiry`.
- Управление ролями: выдача/проверка ролей через `CoreSystem.grantRole`/`hasRole`.
- Обёртки над фабриками (`SubscriptionManagerFactory`, `MarketplaceFactory`) для развертки модулей и регистрации сервисов.
- Методы для:
  - Создания/обновления/деактивации планов.
  - Получения сведений о подписках (`getSubscription`, `listUserPlans`).
  - Работа с депозитами и событиями (подписки, списания).
- Логирование и сохранение соответствия `planHash` ↔ метаданные (URI, условия доступа).

## Billing worker
- Работает как отдельный сервис/крон на backend. Для тестовой среды допускается запуск через `npm run billing:worker`.
- Использует аккаунт с ролью `AUTOMATION_ROLE`.
- Основные операции:
  - Чтение списка активных подписчиков из бэкенд-хранилища или on-chain.
  - Вызов `chargeBatch` с контролем размера батча (`batchLimit` из контракта).
  - Обработка ошибок шлюза/контракта и повторные попытки.
  - Вызов `markFailedCharge` по результатам неудачных транзакций, чтобы включить автоматическую стратегию ретраев.
- Рекомендуется писать события в систему логирования и поднимать алерты при критических ошибках или массовых отказах.

## Логирование и мониторинг
- Подписаться на события `PlanCreated`, `PlanStatusChanged`, `SubscriptionActivated`, `SubscriptionCharged`, `SubscriptionRetryScheduled`, `SubscriptionFailedFinal`.
- Хранить хеши транзакций и расшифрованные параметры событий в аналитическом хранилище.
- Внедрить метрики по количеству активных подписчиков, суммам списаний, доле неудач и времени ретрая.

## Развёртывание и окружения
- **Локальное тестирование**
  - Один кошелёк с полным набором ролей.
  - Hardhat/Anvil сеть, воркер запускается вручную.
  - Мнимый шлюз: простой контракт без комиссий, конвертация 1:1.
- **Стейджинг**
  - Отдельные кошельки для автора, оператора и воркера.
  - Настоящий шлюз с тестовыми токенами.
  - Интеграция с системой логирования и алертинга.
- **Прод**
  - Подлинный шлюз с real-world лимитами и комиссиями.
  - Безопасное хранение ключей (HSM, Vault).
  - Регулярные бэкапы конфигурации (instanceId → контракт, сервисы, роли).

## Следующие шаги
1. Описать API и схемы данных backend-библиотеки.
2. Подготовить план миграции ролей с одного кошелька на разделённые аккаунты.
3. Настроить CI для прогонки воркера и тестов подписок на локальной сети.

## Дополнительные материалы
- Спецификация серверной библиотеки: `docs/billing/backend-library.md`.
- Playbook с операционными шагами: `docs/playbooks/billing.md`.
- Инвентаризация и план расширения воркеров: `docs/billing/worker-inventory.md`.
- Полный бэклог задач: `docs/billing/backlog.md`.
