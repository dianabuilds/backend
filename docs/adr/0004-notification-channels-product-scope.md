# ADR 0004: Перезапуск продуктовой модели уведомлений

- Status: Draft
- Date: 2025-09-24
- Authors: Notifications Working Group
- Tags: notifications, ux, segmentation, scheduling

## Контекст

Текущее решение для уведомлений пыталось объединить три разных сценария (массовые кампании, транзакционные события, подписочные оповещения) в одну сложную форму. Операторам приходилось вручную выбирать статусы и управлять фильтрами, что приводило к непредсказуемому поведению и низкому доверию. Пользовательская ценность — доставить понятное сообщение вовремя — терялась.

Мы стартуем заново, принимая, что код можно полностью переписать: обратная совместимость не требуется, миграция данных выполняется скриптами.

## Проблема

- Интерфейс смешивает несвязанные сценарии и заставляет оператора управлять техническими статусами.
- Аудитория задаётся через подсистему фильтров, которую сложно понять; «отправить всем» выглядит как edge-case.
- Время доставки и статусы конфликтуют (тумблер «Start immediately» + ручной выбор статуса).
- Транзакционные и подписочные события реализуются теми же формами, что и бродкасты, поэтому нет чёткого SLA и аналитики.

Нужно определить новую модель, в которой продукт сфокусирован на человеке, событии и ясном сценарии, а не на внутренних механизмах.

## Решение

### 1. Разделение сценариев

Уведомления делятся на три продукта:

1. **Broadcast** — ручная рассылка, отправляется оператором или маркетингом. Путь «создай контент → выбери аудиторию → назначь время → запусти».
2. **Transactional** — события доменов (биллинг, безопасность). Подразумевают адресное сообщение конкретному пользователю, генерируются API-вызовами.
3. **Subscriptions** — автоматические сигналы по подписке на объект (например, «автор выпустил квест»). Настраиваются через отдельные правила.

Интерфейс и API должны явно указывать, к какому типу относится сущность. Никаких «универсальных» форм.

### 2. Жизненный цикл кампании (Broadcast)

- Статусы вычисляются системой, оператор не редактирует их вручную.
- Диаграмма переходов: `Draft → Scheduled → Sending → Sent | Failed | Cancelled`.
- Действия оператора ограничены кнопками «Отправить сейчас», «Запланировать», «Отменить». При запуске статус меняется автоматически.

### 3. Аудитория

- В форме бродкаста первый шаг — выбор типа аудитории: `all_users`, `segment`, `explicit_users`.
- `all_users` — дефолт, не требует ввода.
- `segment` — визуальный конструктор с ограниченным набором фильтров (`role`, `plan`, `locale`, `region`). Отображаем примерное число получателей.
- `explicit_users` — список идентификаторов (используется редко, например для ручных компенсаций).
- JSON-фильтры и скрытые поля запрещены.

### 4. Тайминг и планирование

- Для бродкаста два режима: `send_now` либо `schedule` с точной датой/временем (UTC).
- Перевод статуса в `Scheduled` происходит, если время в будущем. При наступлении времени система ставит статус `Sending`.
- Повторные кампании (переотправка) — отдельная сущность «Clone campaign», чтобы не вмешиваться в историю.

### 5. Транзакционные события

- Вызываются доменами через API `POST /v1/notifications/events`.
- В payload: `event_type`, `user_id`, `template_id` или инлайн-контент, metadata.
- Ответ API — `event_id` и статус обработки. Сохранение `started_at`, `sent_at`, `failed_count`.
- Нет UI-формы для создания; админка показывает только лог и фильтры по статусу.

### 6. Подписки

- Описываются правилами вида `source = quests`, `trigger = quest_published`, `audience = followers(author_id)`.
- Оператор может включить/выключить правило, выбрать шаблон, но не редактировать фильтры.
- Обработка и доставка реализуются в домене-поставщике в связке с notifications-service.

### 7. Хранение и аналитика

- Общая таблица `notifications_messages` содержит базовые поля: `id`, `type`, `audience_type`, `status`, `created_at`, `scheduled_at`, `started_at`, `finished_at`, `total`, `sent`, `failed`.
- Для broadcast хранится snapshot аудитории (список фильтров или user_ids) в JSONB.
- Для transactional/subscription сохраняем ссылку на источник события (`event_id`, `source_domain`).
- Аналитика строится на уровне фактов доставки, статусы вычисляются из операционных событий.

### 8. UX-решения

- Мастер создания бродкаста из четырёх шагов с превью и финальным подтверждением.
- Рассказ о том, что статус не редактируется вручную (читабельный бейдж и пояснение).
- Для сегментов — подсказки и примерное число получателей.
- Лента логов (для transactional/subscription) только read-only.

### 9. API-изменения

- `/v1/notifications/broadcasts` — CRUD в новой модели.
- `/v1/notifications/broadcasts/{id}/actions/send|schedule|cancel` — явные команды вместо PATCH статуса.
- `/v1/notifications/events` — создание транзакционных уведомлений.
- `/v1/notifications/subscriptions` — управление правилами подписок.
- Все ответы возвращают вычисленные статусы и временные метки, UI не должен хранить собственную копию логики.

### 10. Миграция

1. Экспорт старых кампаний, их статусов и фильтров.
2. Конвертация в новую структуру: `status` пересчитывается (например, `ready` → `draft`), фильтры приводятся к явному сегменту или помечаются как `legacy_segment` (для ручной ревизии).
3. Старые API / UI выключаются после переноса данных и обучения оператора.

## Последствия

- Упрощение UX и снижение ошибок операторов.
- Отделение транзакционных уведомлений от кампаний устраняет гонки статусов и смешение SLA.
- Чёткая модель статусов упрощает аналитику и алерты.
- Бэкенд становится источником истины: любое изменение статуса — результат команды или события, а не прямой PATCH.

## Открытые вопросы

- Нужен ли fallback на альтернативные каналы (email ↔ inbox) для критичных событий? Решить после запуска.
- Нужен ли редактор сегментов для сложных условий (AND/OR)? Пока ограничиваемся простыми фильтрами.
- Какой SLA ожидать от доменных сервисов при публикации событий? Требуется договориться с владельцами доменов.

## Решение принято

WG «Notifications» согласилась на полный перезапуск архитектуры с приоритетом простоты для оператора и автоматизации статусной модели. Дальнейшие документы (API-спеки, UI-гайды) будут ссылаться на это ADR как на исходный артефакт.
