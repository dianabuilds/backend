from __future__ import annotations

from typing import List, Any
from uuid import UUID
from datetime import datetime

from fastapi import APIRouter, Depends, HTTPException
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy.future import select

from app.db.session import get_db
from app.security import ADMIN_AUTH_RESPONSES, require_admin_role
from app.schemas.ai_quests import GenerateQuestIn, GenerationEnqueued, GenerationJobOut
from app.services.ai_quests import enqueue_generation_job
from app.models.ai_generation import GenerationJob, JobStatus
from app.models.quest import Quest
from app.models.user import User

admin_required = require_admin_role({"admin", "moderator"})

router = APIRouter(
    prefix="/admin/ai/quests",
    tags=["admin", "ai-quests"],
    responses=ADMIN_AUTH_RESPONSES,
    dependencies=[Depends(admin_required)],
)


@router.get("/templates", summary="List world templates")
async def list_world_templates(
    db: AsyncSession = Depends(get_db),
    _: Depends = Depends(admin_required),
) -> list[dict[str, Any]]:
    # Заглушка: предустановленные шаблоны миров (id, title, locale).
    # В будущем можно вынести в БД/редактор шаблонов.
    return [
        {"id": "00000000-0000-0000-0000-000000000001", "title": "Fantasy (RU)", "locale": "ru-RU"},
        {"id": "00000000-0000-0000-0000-000000000002", "title": "Sci‑Fi (EN)", "locale": "en-US"},
        {"id": "00000000-0000-0000-0000-000000000003", "title": "Noir Mystery (EN)", "locale": "en-US"},
        {"id": "00000000-0000-0000-0000-000000000004", "title": "Slavic Myth (RU)", "locale": "ru-RU"},
    ]


@router.post("/generate", response_model=GenerationEnqueued, summary="Enqueue AI quest generation")
async def generate_ai_quest(
    body: GenerateQuestIn,
    db: AsyncSession = Depends(get_db),
    current = Depends(admin_required),
    reuse: bool = True,
) -> GenerationEnqueued:
    params = {
        "world_template_id": str(body.world_template_id) if body.world_template_id else None,
        "structure": body.structure,
        "length": body.length,
        "tone": body.tone,
        "genre": body.genre,
        "locale": body.locale,
        "extras": body.extras or {},
    }
    job = await enqueue_generation_job(
        db,
        created_by=getattr(current, "id", None),
        params=params,
        provider=None,
        model=None,
        reuse=reuse,
    )
    await db.commit()
    return GenerationEnqueued(job_id=job.id)


@router.get("/jobs", response_model=list[GenerationJobOut], summary="List AI generation jobs")
async def list_jobs(
    db: AsyncSession = Depends(get_db),
    _: Depends = Depends(admin_required),
) -> list[GenerationJobOut]:
    res = await db.execute(select(GenerationJob).order_by(GenerationJob.created_at.desc()))
    rows = list(res.scalars().all())
    return [GenerationJobOut.model_validate(r) for r in rows]


@router.get("/jobs/{job_id}", response_model=GenerationJobOut, summary="Get job by id")
async def get_job(
    job_id: UUID,
    db: AsyncSession = Depends(get_db),
    _: Depends = Depends(admin_required),
) -> GenerationJobOut:
    job = await db.get(GenerationJob, job_id)
    if not job:
        raise HTTPException(status_code=404, detail="Job not found")
    return GenerationJobOut.model_validate(job)


@router.post("/jobs/{job_id}/simulate_complete", response_model=GenerationJobOut, summary="Simulate job completion (DEV)")
async def simulate_complete(
    job_id: UUID,
    db: AsyncSession = Depends(get_db),
    current: User = Depends(admin_required),
) -> GenerationJobOut:
    job = await db.get(GenerationJob, job_id)
    if not job:
        raise HTTPException(status_code=404, detail="Job not found")

    # Переводим в running, затем completed — симуляция работы воркера
    now = datetime.utcnow()
    if job.status == JobStatus.queued:
        job.status = JobStatus.running
        job.started_at = now

    # Если результат ещё не создан — создадим черновой квест
    if not job.result_quest_id:
        title = f"AI Quest ({job.params.get('structure','?')}/{job.params.get('length','?')}/{job.params.get('tone','?')})"
        q = Quest(
            title=title,
            subtitle=None,
            description=f"Generated by AI ({job.params.get('genre','genre')})",
            author_id=current.id,
            is_draft=True,
            structure=job.params.get("structure"),
            length=job.params.get("length"),
            tone=job.params.get("tone"),
            genre=job.params.get("genre"),
            locale=job.params.get("locale"),
        )
        db.add(q)
        await db.flush()
        job.result_quest_id = q.id

    # Заполним стоимость/токены заглушкой
    job.cost = job.cost or 0.0123
    job.token_usage = job.token_usage or {"prompt_tokens": 1024, "completion_tokens": 4096}
    # Сохраним стоимость в квест
    q = await db.get(Quest, job.result_quest_id) if job.result_quest_id else None
    if q:
        try:
            q.cost_generation = int(round(float(job.cost or 0) * 100))
        except Exception:
            q.cost_generation = None
        if not q.structure:
            q.structure = job.params.get("structure")
        if not q.length:
            q.length = job.params.get("length")
        if not q.tone:
            q.tone = job.params.get("tone")
        if not q.genre:
            q.genre = job.params.get("genre")
        if not q.locale:
            q.locale = job.params.get("locale")

    # Прогресс и лог
    job.progress = 100
    logs = list(job.logs or [])
    logs.append(f"[{datetime.utcnow().isoformat()}] Job completed")
    job.logs = logs

    job.status = JobStatus.completed
    job.finished_at = datetime.utcnow()

    await db.commit()
    await db.refresh(job)
    return GenerationJobOut.model_validate(job)


@router.post("/jobs/{job_id}/tick", response_model=GenerationJobOut, summary="Advance job progress (DEV)")
async def tick_job(
    job_id: UUID,
    body: dict = None,
    db: AsyncSession = Depends(get_db),
    current: User = Depends(admin_required),
) -> GenerationJobOut:
    from app.schemas.ai_quests import TickIn

    job = await db.get(GenerationJob, job_id)
    if not job:
        raise HTTPException(status_code=404, detail="Job not found")

    payload = TickIn(**(body or {}))
    # Обновляем статус/время
    now = datetime.utcnow()
    if job.status == JobStatus.queued:
        job.status = JobStatus.running
        job.started_at = now
    if job.status == JobStatus.running:
        job.progress = max(0, min(100, int((job.progress or 0) + payload.delta)))
        if job.progress >= 100:
            job.status = JobStatus.completed
            job.finished_at = datetime.utcnow()
    # Логи
    logs = list(job.logs or [])
    logs.append(f"[{datetime.utcnow().isoformat()}] Tick {payload.delta}%{(' - ' + payload.message) if payload.message else ''}")
    job.logs = logs

    await db.commit()
    await db.refresh(job)
    return GenerationJobOut.model_validate(job)
